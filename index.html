<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mazen Hassani Portfolio</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Set up the scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff, 1); // Set background to white
    document.body.appendChild(renderer.domElement);

    // Add OrbitControls for scene interaction
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Smooth rotation
    controls.dampingFactor = 0.1;
    controls.enableZoom = true;
    controls.minDistance = 5;
    controls.maxDistance = 15;

    // Group to hold all small cubes
    const rubiksCubeGroup = new THREE.Group();
    scene.add(rubiksCubeGroup);

    // Size and spacing of cubes
    const cubeSize = 0.9;
    const spacing = 0.1;
    const colors = [
      0xE67C3B, // Custom Orange
      0xE1E831, // Custom Yellow
      0x64C08C, // Custom Green
      0xA074C5, // Custom Purple
      0xA9D4FF, // Custom Light Blue
      0x2C6EC5  // Custom Blue
    ];

    // Raycaster and mouse setup
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedCube = null; // Cube being dragged
    let isDragging = false;

    // Create individual cubes
    function createSmallCube(x, y, z) {
      const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      const materials = colors.map(color => new THREE.MeshBasicMaterial({ color }));
      const cube = new THREE.Mesh(geometry, materials);
      cube.position.set(
        x * (cubeSize + spacing),
        y * (cubeSize + spacing),
        z * (cubeSize + spacing)
      );
      rubiksCubeGroup.add(cube);
    }

    // Create 3x3x3 Rubik's Cube
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          createSmallCube(x, y, z);
        }
      }
    }

    // Lighting
    const light = new THREE.AmbientLight(0x404040, 2);
    scene.add(light);

    // Position the camera
    camera.position.set(6, 6, 12);
    camera.lookAt(0, 0, 0);

    // Handle mouse down
    function onMouseDown(event) {
      isDragging = true;

      // Convert mouse position to normalized device coordinates
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast to find intersected objects
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(rubiksCubeGroup.children);

      if (intersects.length > 0) {
        selectedCube = intersects[0].object; // Select the cube
      }
    }

    // Handle mouse move
    function onMouseMove(event) {
      if (isDragging && selectedCube) {
        // Convert mouse position to normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Update raycaster to project cube's new position
        raycaster.setFromCamera(mouse, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Move along the Z-plane
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, intersectPoint);

        // Update cube position
        selectedCube.position.copy(intersectPoint);
      }
    }

    // Handle mouse up
    function onMouseUp() {
      isDragging = false;
      selectedCube = null; // Deselect the cube
    }

    // Add event listeners
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // Update OrbitControls
      renderer.render(scene, camera); // Render the scene
    }
    animate();
  </script>
</body>
</html>
